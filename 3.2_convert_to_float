.data     
  #Function 1 - Read txt.
  xtrain_txt:   .asciiz "xtrain.txt" 
  xtrain_array: .space 18000 # Array characters 
  
  ytrain_txt:   .asciiz "ytrain.txt" 
  ytrain_array: .space 18000 # Array characters 
  
  #Function 2 - Get User Input
  str_num: .asciiz "Quantos numeros deseja inserir? (maximo 200)\n"
  user_input: .word 0   # variable to user's input 	 	
  check_input_msg: .asciiz "You entered: "

  #Function 3 - Convert to Float
  xtrain_array_float:   .align 2
  	     .space 6400   # Array floats  		
  partial_string:       .space 15

  float_constant:       .float 0.0     # Initialize a float constant
  float_ten:            .float 10.0    # Declare a float constant
  float_hundred:        .float 100.0   # Declare a float constant
  float_thousand:       .float 1000.0  # Declare a float constant
  				
.text
.globl main

main:
  jal get_user_input
  
  jal read_xtrain 
  
  jal read_ytrain     

  jal convert_to_float

  # Exit the program
  li $v0, 10        # syscall 10 (exit)
  syscall

########################### FUNCTIONS ################################################################################## 

####### 1) FUNCTION - READ FILES ####################################################################################### 
####### 1.1) READ xtrain.txt 
read_xtrain: 
  li $v0, 13       # syscall 13 (open file)
  la $a0, xtrain_txt # Load the xtrain_txt
  li $a1, 0        # Read-only mode
  li $a2, 0        # File permissions (ignored)
  syscall
  
  move $s0, $v0
 
  li $v0, 14        # syscall 14 (read file)
  move $a0, $s0      # file descriptor 

  la $a1, xtrain_array   
  li $a2, 18000
  syscall

  # Null-terminate the copied string  
  addi $t0, $a1, 18000
  sb $zero, ($t0)       # Null-terminate at the end
  
  ############ TESTE ##################		
  # Print the copied content
  #li $v0, 4         # syscall 4 (print string)
  #la $a0, xtrain_array # Load the string to print
  #syscall
  
  # Close the file
  li $v0, 16        # syscall 16 (close file)
  syscall		

  jr $ra	
  
####### 1.2) READ ytrain.txt 
read_ytrain: 
  li $v0, 13       # syscall 13 (open file)
  la $a0, ytrain_txt 
  li $a1, 0        # Read-only mode
  li $a2, 0        # File permissions (ignored)
  syscall
  
  move $s0, $v0
 
  li $v0, 14        # syscall 14 (read file)
  move $a0, $s0      # file descriptor 

  la $a1, ytrain_array  
  li $a2, 18000
  syscall

  # Null-terminate the copied string  
  addi $t0, $a1, 18000
  sb $zero, ($t0)       # Null-terminate at the end
  
  ############ TESTE ##################		
  # Print the copied content
  #li $v0, 4         # syscall 4 (print string)
  #la $a0, ytrain_array  # Load the string to print
  #syscall
  
  # Close the file
  li $v0, 16        # syscall 16 (close file)
  syscall		

  jr $ra

####### 2) FUNCTION - GET USER INPUT #######################################################################################

get_user_input:
  la $a0, str_num # print 'str_num'
  li $v0, 4
  syscall
    
  li $v0, 5  # read an integer from the user
  syscall  
  
  sw $v0, user_input # Store the result
  
  # Display a message to check the user's input
  la $a0, check_input_msg
  li $v0, 4  
  syscall 
  
  lw $a0, user_input  # Load the user's input from the variable
  li $v0, 1
  syscall
  
  jr $ra  
  
####### FUNCTION 3) CONVERT TO FLOAT #######################################################################################
convert_to_float:
  # Initialize variables
  li $t0, 0                                 # loop counter for 'convert_to_float'
  li $t1, 0                                 # index for 'xtrain_array'
  li $t2, 0                                 # index for 'xtrain_array_float'
  li $t3, 0                                 # index for 'partial_string'
  li $t4, 0
  li $t5, 0
  li $t6, 0 
  lw $a0, user_input                        # user input
  
  # 3.1) CREATE PARTIA STRING              
  # Loop to create 'partial_string' array 	
  loop_get_chars_to_partial_string:          # Loop to create 'partial_string' array
   
   lb $t5, xtrain_array($t1)                 # Load a character from xtrain_array   
                       
   beq $t5, 0x2C, final_partial_string     # check: comma (',') 
   beq $t5, 0x00, final_partial_string     # check: null-terminator ('\0')
   beq $t5, 0xA, final_partial_string      # check:  new-line  ('\n')
     
   # Check if it's a decimal digit (0-9)
   li $t4, 48                                # ASCII code for '0'
   li $t6, 57                                # ASCII code for '9'
   blt $t5, $t4, not_decimal_or_period       # Branch if character is less than '0'
   bgt $t5, $t6, not_decimal_or_period       # Branch if character is greater than '9'
   
   # Check if it's a period ('.')
   li $t4, 46                                # ASCII code for a period ('.')
   bne $t5, $t4, not_decimal_or_period 
  
   # At this point is a 'decimal' or 'period'
   sb $t5, partial_string($t3)               # Add character to partial_string
   addi $t1, $t1, 1                          # increment 'xtrain_array(index)'
   addi $t3, $t3, 1                          # increment 'partial_string(index)'
   j loop_get_chars_to_partial_string  
   
   not_decimal_or_period:
    addi $t1, $t1, 1                         # increment 'xtrain_array(index)'
    addi $t3, $t3, 1                         # increment 'partial_string(index)'                        
    j loop_get_chars_to_partial_string                          
   
   final_partial_string:
   # Null-terminate the partial_string
   addi $t3, $t3, 1 
   sb $zero, partial_string($t3)             
   
   li, $t3, 0                                # reset index 
   addi $t1, $t1, 1                          # increment for next loop of convert_to_float                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
   j loop_get_chars_to_partial_string  	

# 3.2) CONVERT 'partial_string' TO FLOAT    
  process_partial_string:                
           
   # Initialize variables 
   li $t4, 0
   li $t5, 4
   li $t6, 0  
   li $t7, 0                                 # Index for 'adjust_format_float'
   li $t8, 0
   li $t9, 46                                # ASCII code for period ('.') 
              
  adjust_to_float_loop:            
   lb $t8, partial_string($t7)
   addi $t7, $t7, 1    
   beq $t5, $t7, loop_numbers_before_period  # case when there is no decimal                            
   bne $t8, $t9, adjust_to_float_loop        # Stops loop when it finds the period '.'                            
   
   #print
   li $v0, 11                 
   lb $a0, partial_string($t7) 
   syscall                                              
                                                                                                                                                   
   loop_numbers_after_period:
    # get first digit AFTER period (ex. 0.1)
    li $t3, 0
    add $t3, $t3, $t7
    lbu $t5, partial_string($t3)             # $t7 index of first digit AFTER the period
    sub $t5, $t5, 48                         # convert ASCII to integer 
    mtc1 $t5, $f2
    cvt.s.w $f2, $f2                         # convert to float 
    l.s $f6, float_ten  
    div.s $f2, $f2, $f6                      # divide by 10    
    add.s $f0, $f0, $f2                      # $f0 will store the final float
    
    # get second digit AFTER period (ex. 0.1)
    addi $t3, $t3, 1 
    lbu $t5, partial_string($t3)
    beqz $t5, loop_numbers_before_period
    sub $t5, $t5, 48                         # convert ASCII to integer 
    mtc1 $t5, $f2                            # convert to float
    cvt.s.w $f2, $f2                         # convert to float  
    l.s $f6, float_hundred  
    div.s $f2, $f2, $f6                      # divide by 100    
    add.s $f0, $f0, $f2                      # $f0 will store the final float
 
    # get third digit AFTER period (ex. 0.1)
    addi $t3, $t3, 1 
    lbu $t5, partial_string($t3)
    beqz $t5, loop_numbers_before_period
    sub $t5, $t5, 48                         # convert ASCII to integer 
    mtc1 $t5, $f2                            
    cvt.s.w $f2, $f2                         # convert to float # convert to float 
    l.s $f6, float_thousand  
    div.s $f2, $f2, $f6                      # divide by 1000    
    add.s $f0, $f0, $f2                      # $f0 will store the final float                                                                           
                                                                                                                                         
   loop_numbers_before_period:                   
    # get first digit BEFORE period (ex. 1.0)
    subi  $t3, $t7, 2                	       # index of first digit BEFORE the period
    lbu $t5, partial_string($t3)             # load the ASCII character
    sub $t5, $t5, 48                         # convert ASCII to integer        
    mtc1 $t5, $f2                            # copy to float register   
    cvt.s.w $f2, $f2                         # convert to a float
    add.s $f0, $f0, $f2                      # $f0 will store the final float   
        
    # get second digit BEFORE period (ex. 10.0)
    subi  $t3, $t3, 1
    bltz $t3, exit_convert_to_float 
    lbu $t5, partial_string($t3)
    sub $t5, $t5, 48       
    li $t6, 10  
    mul $t5, $t5, $t6                        # multiply by 10  
    mtc1 $t5, $f2                            # copy to float register
    cvt.s.w $f2, $f2                         # convert to a float                           
    add.s $f0, $f0, $f2	       # $f0 will store the final float
    	
    # get third digit BEFORE period (ex. 100.0)
    subi  $t3, $t3, 1
    bltz $t3, exit_convert_to_float
    lbu $t5, partial_string($t3)
    sub $t5, $t5, 48
    li $t6, 100
    mul $t5, $t5, $t6                        # multiply by 100
    mtc1 $t5, $f2		       # copy to float register	
    cvt.s.w $f2, $f2                         # convert to a float
    add.s $f0, $f0, $f2                      # $f0 will store the final float 
      
   exit_convert_to_float:        
    ############ Print para Teste ##################
    li $v0, 2         # 'print float' system call  
    mov.s $f12, $f0   # '$f12' is the register used to pass arguments for printin 
    syscall         

    sll $t2, $t0, 2    	       # calculate offset 	
    la $t3, xtrain_array_float                               
    add $t2, $t2, $t3                        # add the base address to offset 
    s.s $f0, 0($t2)    
    addi $t0, $t0, 1			
    
    # clean partial_string
    li $t3, 0
    li $t9, 15
    loop_reset_partial_string:       
     sb $zero, partial_string($t3)           # Set the byte at 'partial_string'[$t3] to zero
     addi $t3, $t3, 1                        # Increment index
     beq $t3, $t9 done_reset_partial_string  # Check if we have reset the entire array

    done_reset_partial_string:
    li $t3, 0    
    bne $t0, $a0, loop_get_chars_to_partial_string   # Check if the 'loop counter' equals 'user_input_number'                                                                               
                                                                                                                                                                                                                                                    
    jr $ra     
